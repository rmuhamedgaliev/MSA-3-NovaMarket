# ADR: Реализация истории заказов с использованием CQRS

## **Название задачи:** 
Реализация функциональности просмотра истории заказов с агрегированными данными

## **Автор:**

Rinat Muhamedgaliev

## **Дата:**
2025-01-07

## **Функциональные требования**

|**№**|**Действующие лица или системы**|**Use Case**|**Описание**|
| :-: | :- | :- | :- |
|1|Покупатель|Просмотр истории заказов|Покупатель может просмотреть список всех своих заказов с основной информацией (дата, сумма, статус)|
|2|Покупатель|Детальный просмотр заказа|Покупатель может открыть детальную информацию о конкретном заказе (товары, цены, способы доставки и оплаты)|
|3|Покупатель|Скачивание чека|Покупатель может скачать чек по завершенному заказу|
|4|Покупатель|Оставление отзыва|Покупатель может оставить отзыв о товаре из заказа|
|5|Покупатель|Повторный заказ|Покупатель может заказать товары из предыдущего заказа повторно|

## **Нефункциональные требования**

|**№**|**Требование**|
| :-: | :- |
|1|Время отклика интерфейса < 1 сек в 99.99% случаев|
|2|Время отклика интерфейса < 0.3 сек в 98% случаев|
|3|Масштабируемость до 40,000+ заказов в день|
|4|Высокая доступность (99.9%)|
|5|Консистентность данных в течение 5 минут|
|6|Поддержка сложных запросов по истории заказов|

## **Решение**

### Архитектурное решение: CQRS (Command Query Responsibility Segregation)

Для реализации функциональности истории заказов выбран паттерн CQRS, который разделяет операции чтения и записи данных.

#### Диаграмма архитектуры

![Container Diagram](img/container-diagram.png)

#### Основные компоненты решения:

1. **Order History Service** - специализированный сервис для чтения истории заказов
2. **Order History Database** - оптимизированная read-модель для быстрых запросов
3. **Redis Cache** - кэширование часто запрашиваемых данных
4. **Review Service** - управление отзывами
5. **Receipt Service** - генерация и выдача чеков

#### Логика принятия решений:

- **Разделение ответственности**: Write-операции остаются в Order Service, read-операции вынесены в специализированный Order History Service
- **Оптимизация производительности**: Read-модель оптимизирована под запросы истории заказов с денормализованными данными
- **Кэширование**: Redis обеспечивает быстрый доступ к часто запрашиваемым данным
- **Event-driven обновление**: Read-модель обновляется асинхронно через события из write-модели

## **Альтернативы**

### 1. API Composition
**Описание**: Агрегация данных из нескольких сервисов на уровне API Gateway

**Плюсы**:
- Простота реализации
- Не требует дополнительной инфраструктуры
- Быстрое внедрение

**Минусы**:
- Медленный отклик при множественных запросах
- Высокая нагрузка на write-сервисы
- Сложность кэширования
- Нарушение принципа единственной ответственности

### 2. Event Sourcing
**Описание**: Хранение всех изменений состояния в виде событий

**Плюсы**:
- Полная история изменений
- Возможность восстановления состояния на любой момент времени
- Аудит всех операций

**Минусы**:
- Высокая сложность реализации
- Большой объем данных
- Сложность запросов по истории
- Избыточность для простых случаев

### 3. CQRS + Event Sourcing
**Описание**: Комбинация CQRS с Event Sourcing

**Плюсы**:
- Полная история + быстрые запросы
- Максимальная гибкость

**Минусы**:
- Очень высокая сложность
- Избыточность для текущих требований
- Сложность сопровождения

## **Недостатки, ограничения, риски**

### Недостатки выбранного решения:

1. **Сложность синхронизации**: Read-модель может отставать от write-модели
2. **Дублирование данных**: Данные хранятся в двух местах
3. **Дополнительная инфраструктура**: Требуется дополнительный сервис и база данных
4. **Сложность отладки**: Проблемы могут возникать как в write, так и в read части

### Ограничения:

1. **Eventual Consistency**: Данные в read-модели могут быть неактуальными до 5 минут
2. **Сложность запросов**: Сложные аналитические запросы могут потребовать дополнительной обработки
3. **Размер кэша**: Redis может потребовать значительных ресурсов при росте данных

### Риски:

1. **Риск рассинхронизации**: При сбоях в event bus read-модель может стать неактуальной
2. **Риск потери производительности**: При неправильной настройке кэша производительность может ухудшиться
3. **Риск усложнения**: Команда может не справиться с дополнительной сложностью архитектуры

### Меры по снижению рисков:

1. **Мониторинг синхронизации**: Реализация алертов на отставание read-модели
2. **Резервные механизмы**: Возможность переключения на API Composition при сбоях
3. **Документация и обучение**: Подробная документация для команды разработки
4. **Постепенное внедрение**: Пилотное внедрение с ограниченным функционалом
